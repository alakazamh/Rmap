#!/usr/bin/env bash

# Rmap — (c) 2025 freshM1 — MIT License
# See LICENSE file for details.

set -uo pipefail

# ======================
# Rmap - enhanced w/ rustscan
# ======================
# Colors / formatting (readonly)
readonly FG_GREEN=$'\e[1;32m'
readonly FG_RED_BOLD=$'\e[1;31m'
readonly FG_CYAN_BOLD=$'\e[1;36m'
readonly FG_CYAN=$'\e[0;36m'
readonly FG_MAGENTA_BOLD=$'\e[1;35m'
readonly FG_MAGENTA=$'\e[0;35m'
readonly BOLD=$'\e[1m'
readonly RESET=$'\e[0m'
readonly FG_YELLOW=$'\e[1;33m'

# Defaults for options
use_rustscan=0
nmap_oN_path=""
nmap_oA_prefix=""
rust_args=""            # extra args to pass to rustscan (string)
save_rust_out=0         # save rustscan raw stdout to file
rust_out_path=""        # path for raw rustscan stdout

usage() {
  cat <<EOF
Usage: $0 [options] <target>

Options:
      -r, --rustscan            Use rustscan for discovery (default: rustscan -a <target> -r 1-65535 --ulimit=5000)
          --rust-args "<args>"  Extra args to append to rustscan invocation (quoted).
          --save-rust <file>    Save raw rustscan stdout to <file>.
      --nmap-oN <file>         Save final Nmap human-readable output to <file> (like -oN).
      --nmap-oA <pre>          Save final Nmap outputs in all formats (-oA <pre>).
  -h, --help                   Show this help.
Notes:
  Options may be given before or after the target.
EOF
}

# ---- parse args (accept options anywhere) ----
target=""
while (( $# )); do
  case "$1" in
    --nmap-oN)
      if [[ -z "${2:-}" ]]; then echo "Missing argument for --nmap-oN" >&2; usage; exit 2; fi
      nmap_oN_path="$2"; shift 2
      ;;
    --nmap-oA)
      if [[ -z "${2:-}" ]]; then echo "Missing argument for --nmap-oA" >&2; usage; exit 2; fi
      nmap_oA_prefix="$2"; shift 2
      ;;
    -r|--rustscan)
      use_rustscan=1; shift
      ;;
    --rust-args)
      if [[ -z "${2:-}" ]]; then echo "Missing argument for --rust-args" >&2; usage; exit 2; fi
      rust_args="$2"; shift 2
      ;;
    --save-rust)
      if [[ -z "${2:-}" ]]; then echo "Missing argument for --save-rust" >&2; usage; exit 2; fi
      save_rust_out=1; rust_out_path="$2"; shift 2
      ;;
    -h|--help) usage; exit 0 ;;
    --) shift; break ;;
    -*)
      echo "Unknown option: $1" >&2; usage; exit 2
      ;;
    *)
      if [[ -z "$target" ]]; then
        target="$1"
      else
        # allow extra positional args if needed later
        :
      fi
      shift
      ;;
  esac
done

if [[ -z "$target" ]]; then
  echo "Usage: $0 [options] <target>"
  exit 1
fi

# ---- banner (unchanged style) ----
print_banner() {
  [[ -t 1 ]] || return 0
  local title="${1:-Rmap!}"
  local termcols=80
  if command -v tput >/dev/null 2>&1; then
    termcols="$(tput cols 2>/dev/null || echo 80)"
  fi
  _center_line(){ local l="$1"; local len=${#l}; if (( len>=termcols )); then printf '%s\n' "$l"; else local pad=$(( (termcols-len)/2 )); printf '%*s%s\n' "$pad" '' "$l"; fi }
  if command -v figlet >/dev/null 2>&1; then
    figlet -f slant "$title" 2>/dev/null | while IFS= read -r ln; do printf '%b' "${FG_CYAN_BOLD}"; _center_line "$ln"; printf '%b' "${RESET}"; done
  else
    local -r fallback=$'\n    ____                        __\n   / __ \\____ ___  ____ _____  / /\n  / /_/ / __ `__ \\/ __ `/ __ \\/ /\n / _, _/ / / / / / /_/ / /_/ /_/\n/_/ |_/_/ /_/ /_/\\__,_/ .___(_)\n                     /_/\n'
    while IFS= read -r ln; do printf '%b' "${FG_CYAN_BOLD}"; _center_line "$ln"; printf '%b' "${RESET}"; done <<< "$fallback"
  fi
  printf '\n'
  printf '%b' "${FG_MAGENTA}"; _center_line "Rmap - quick targeted scan"; printf '%b\n\n' "${RESET}"
}
print_banner "Rmap!"

# ---- basic tools check (core tools) ----
for cmd in nmap awk sed grep sort paste mktemp pkill; do
  if ! command -v "$cmd" >/dev/null 2>&1; then
    printf '%bMissing required command: %s%b\n' "${FG_RED_BOLD}" "$cmd" "${RESET}" >&2
    exit 3
  fi
done

# If rustscan mode requested, make sure rustscan exists
if (( use_rustscan )); then
  if ! command -v rustscan >/dev/null 2>&1; then
    printf '%bRustscan requested but not found in PATH. Install rustscan or remove -r flag.%b\n' "${FG_RED_BOLD}" "${RESET}" >&2
    exit 3
  fi
fi

# ---- tempdir and cleanup ----
tmpdir="$(mktemp -d /tmp/rmap.XXXXXX)"
cleanup_all() {
  pkill -P $$ >/dev/null 2>&1 || true
  rm -rf "${tmpdir}" >/dev/null 2>&1 || true
}
trap cleanup_all INT TERM EXIT

# breathe helpers
breathe_period=8
breathe_target_slowdown=3
_breathe_phase(){ local tick=$1; local phase=$(( tick % breathe_period )); if (( phase < (breathe_period/2) )); then printf "%b" "${FG_MAGENTA}"; else printf "%b" "${FG_MAGENTA_BOLD}"; fi }
_breathe_reset(){ printf "%b" "${RESET}"; }

# -----------------------------
# Discovery phase: nmap probe (full-range fast SYN to find open ports) or rustscan (if -r)
# -----------------------------
probe_out="${tmpdir}/nmap_probe.gnmap"   # used by downstream parser
probe_stdout="${tmpdir}/nmap_probe.stdout"
probe_err="${tmpdir}/nmap_probe.err"

# run probe: either nmap or rustscan
if (( use_rustscan )); then
  # build rustscan command
  # default flags: -a "$target" -r 1-65535 --ulimit=5000
  # allow appending extra args via --rust-args
  rust_cmd=(rustscan -a "$target" -r 1-65535 --ulimit=5000)
  if [[ -n "$rust_args" ]]; then
    # shell-split the user-provided rust_args safely: use eval-like array expansion
    # we conservatively append as one item and let the shell interpret; user should quote correctly
    # Convert rust_args into array (simple split on spaces)
    read -r -a extra <<< "${rust_args}"
    rust_cmd+=("${extra[@]}")
  fi

  # run rustscan
  printf '%b%s %s %b\n' "${FG_CYAN}" "Running rustscan:" "${rust_cmd[*]}" "${RESET}"
  "${rust_cmd[@]}" 1> "${probe_stdout}" 2>"${probe_err}" &
  probe_pid=$!
else
  # NOTE: we use -oG to get gnmap parse-friendly output; --open to show only hosts/ports that are open
  nmap -p1-65535 -T4 --min-rate 1000 -Pn -sS --open -oG "${probe_out}" "$target" 1> "${probe_stdout}" 2>"${probe_err}" &
  probe_pid=$!
fi

# spinner while probe runs
frames=( '⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' )
i=0
delay=0.12
while kill -0 "$probe_pid" 2>/dev/null; do
  tick_for_target=$(( i / breathe_target_slowdown ))
  bc="$(_breathe_phase "$tick_for_target")"
  printf '\r%b : [ %b%s%b ] %b%s scanning (probe)%b  ' \
    "SCANNING TARGET" "${bc}" "${target}" "${RESET}" "${FG_MAGENTA_BOLD}" "${frames[i]}" "${RESET}"
  i=$(( (i + 1) % ${#frames[@]} ))
  sleep "$delay"
done

wait "$probe_pid"
probe_rc=$?
# clear spinner line
printf '\r'

# optionally save the raw rustscan stdout if requested
if (( save_rust_out )) && (( use_rustscan )); then
  if [[ -n "$rust_out_path" ]]; then
    cp -f "${probe_stdout}" "${rust_out_path}" 2>/dev/null || true
    printf '%bRustscan raw output saved to: %s%b\n' "${FG_CYAN_BOLD}" "${rust_out_path}" "${RESET}"
  fi
fi

# Show only RustScan banner and intro (hide logs, [~], Open lines, and Nmap prep)
if [[ -s "${probe_stdout}" ]]; then
  awk '
    # Arrêter juste avant le tableau Nmap final
    /^PORT[[:space:]]+STATE[[:space:]]+SERVICE/ {exit}

    # Supprimer les lignes de bruit ou de log
    /^\[~\]/ {next}
    /^Open / {next}
    /^DNS resolution/ {next}
    /^Scanned at/ {next}
    /^Initiating/ {next}
    /^Discovered/ {next}
    /^Completed/ {next}
    /^Host is up/ {next}
    /^Nmap scan report/ {next}
    /^Read data files/ {next}
    /^Nmap done/ {next}
    /^Scanning/ {next}

    # Conserver tout le reste (bannière, texte RustScan, etc.)
    {print}
  ' "${probe_stdout}" | sed '/^$/d'
fi


# if probe error present, show a trimmed version (helpful)
if [[ -s "${probe_err}" ]]; then
  printf '\n%b=== Probe stderr (trimmed) ===%b\n' "${FG_RED_BOLD}" "${RESET}"
  sed -n '1,200p' "${probe_err}" || true
fi

if [[ $probe_rc -ne 0 ]]; then
  printf '%bProbe scan failed (rc=%d). See %s and %s%b\n' "${FG_RED_BOLD}" "$probe_rc" "${probe_out}" "${probe_err}" "${RESET}" >&2
  # if rustscan failed but nmap was intended fallback, let it keep going only if probe_out exists
  if [[ -f "${probe_out}" ]]; then
    printf '%bProceeding with existing %s (if any).%b\n' "${FG_YELLOW}" "${probe_out}" "${RESET}"
  else
    exit "$probe_rc"
  fi
fi

# -------------------------
# Parse discovery output (works for gnmap or rustscan)
# -------------------------
# If rustscan used: try robust heuristics to extract ports and synthesize gnmap-like file for compatibility
if (( use_rustscan )); then
  # Several heuristics to extract ports from rustscan stdout:
  # 1) Look for common phrases: "Open ports:", "discovered", "open:" lines
  # 2) Look for "PORT" style table lines (e.g., "22/tcp open  ssh")
  # 3) Fallback: extract all numbers in 1..65535 but avoid "ulimit" numbers and obvious noise
  ports=""
  # heuristic 1
  ports=$(
    grep -Ei 'open ports|discovered|open:' "${probe_stdout}" 2>/dev/null \
      | grep -oE '[0-9]{1,5}' \
      | awk '$1>=1 && $1<=65535' \
      | sort -n -u \
      | paste -sd, - || true
  )

  # heuristic 2: look for patterns like "22/tcp" or "22/tcp open"
  if [[ -z "$ports" ]]; then
    ports=$(
      grep -oE '[0-9]{1,5}/tcp' "${probe_stdout}" 2>/dev/null \
        | sed 's#/tcp##' \
        | awk '$1>=1 && $1<=65535' \
        | sort -n -u \
        | paste -sd, - || true
    )
  fi

  # heuristic 3 fallback: extract numbers but exclude common non-port markers
  if [[ -z "$ports" ]]; then
    ports=$(
      grep -v -i 'ulimit' "${probe_stdout}" 2>/dev/null \
        | grep -oE '[0-9]{1,5}' \
        | awk '$1>=1 && $1<=65535' \
        | sort -n -u \
        | paste -sd, - || true
    )
  fi

  # If still empty, try JSON-ish lines (some rustscan builds may print JSON)
  if [[ -z "$ports" ]]; then
    ports=$(
      grep -oE '"ports":[[:space:]]*\[[0-9, ]+\]' "${probe_stdout}" 2>/dev/null \
        | sed -E 's/.*\[(.*)\].*/\1/' \
        | tr ',' '\n' \
        | awk '{$1=$1; print}' \
        | awk '$1>=1 && $1<=65535' \
        | sort -n -u \
        | paste -sd, - || true
    )
  fi

  if [[ -z "$ports" ]]; then
    printf '%bNo ports found by rustscan for %s. Will fallback to running a quick nmap -p1-1024 probe (this is a safety fallback).%b\n' "${FG_RED_BOLD}" "${target}" "${RESET}" >&2
    # fallback: run a narrow nmap probe to avoid total failure
    nmap -p1-1024 -T4 --min-rate 1000 -Pn -sS --open -oG "${probe_out}" "$target" 1> "${probe_stdout}" 2>"${probe_err}"
    # parse the generated probe_out below
  else
    # synthesize a gnmap-like line for downstream parsing
    IFS=',' read -r -a port_arr <<< "$ports"
    port_entries=()
    for p in "${port_arr[@]}"; do
      port_entries+=("${p}/open/tcp//")
    done
    port_entries_joined="$(printf '%s,' "${port_entries[@]}" | sed 's/,$//')"
    printf '%s\n' "Host: ${target} ()  Ports: ${port_entries_joined}" > "${probe_out}"
  fi
fi

# --- ensure ports variable exists for both rustscan and nmap-only paths ---
ports="${ports:-}"

# If ports empty (e.g. we ran nmap -oG in non-rustscan mode), parse the gnmap output.
if [[ -z "${ports:-}" ]] && [[ -f "${probe_out}" ]]; then
  ports=$(
    # sed extracts the "Ports: ..." portion from gnmap lines and we pull the numeric port
    sed -n 's/.*Ports: //p' "${probe_out}" 2>/dev/null \
      | tr ',' '\n' \
      | awk -F'/' '/\/open\// {print $1}' \
      | sort -n -u \
      | paste -sd, - || true
  )
fi


# Clean the rustscan/nmap output before parsing (remove verbose lines)
sed -E '/^(Discovered|Starting|Initiating|Completed|DNS|Host is up|Nmap scan report|Service detection|Scanning|Read data files from|Nmap done)/d' \
  "${probe_stdout}" | grep -vE '^\[~\]|^Open|^RustScan:|^You miss|^: |^__|^  /_|^\| |^-|^$' \
  > "${probe_stdout}.clean"
probe_stdout="${probe_stdout}.clean"

# Build a temporary summary (for clean parsing)
tmp_summary=$(mktemp /tmp/rmap_summary.XXXXXX)
awk '
  BEGIN {in_table=0}
  /^PORT[[:space:]]+STATE[[:space:]]+SERVICE/ {in_table=1; print; next}
  in_table && NF==0 {in_table=0; exit}
  in_table {print}
' "${probe_stdout}" > "$tmp_summary" || true

echo
# Clean and minimal output
if [[ -s "$tmp_summary" ]]; then
  # print table header
  { read -r hdr || true; } < "$tmp_summary"
  if [[ -n "$hdr" ]]; then
    printf '%b%s%b\n' "${FG_CYAN}" "$hdr" "${RESET}"
    sed -n '2,999p' "$tmp_summary" || true
  fi
else
  printf '%b(no service table found)%b\n' "${FG_RED_BOLD}" "${RESET}"
fi
rm -f "$tmp_summary"

echo
printf '%bRead data files from:%b /usr/share/nmap\n' "${BOLD}" "${RESET}"
printf '%bNmap done:%b 1 IP address (1 host up) scanned.\n' "${BOLD}" "${RESET}"
echo "           Raw packets sent: $(awk '/Raw packets sent/ {print $4, $5, $6}' "${probe_stdout}" 2>/dev/null) |"

if [[ -z "${ports:-}" ]]; then
  printf '%b%s%b\n' "${FG_RED_BOLD}" "No ports found or discovery scan failed for ${target}" "${RESET}"
  exit 2
fi



# -----------------------------
# Run targeted Nmap scan on discovered ports
# -----------------------------
echo
nmap_err="${tmpdir}/nmap_targeted.err"

if [[ -n "${nmap_oA_prefix}" ]]; then
  final_nmap_cmd=(nmap --privileged -p"$ports" -sC -sV -Pn -sS --min-rate 1000 "$target" -oA "${nmap_oA_prefix}")
  "${final_nmap_cmd[@]}" 1>/dev/null 2>"${nmap_err}" &
  nmap_pid=$!
elif [[ -n "${nmap_oN_path}" ]]; then
  final_nmap_cmd=(nmap --privileged -p"$ports" -sC -sV -Pn -sS --min-rate 1000 "$target" -oN "${nmap_oN_path}")
  "${final_nmap_cmd[@]}" 1>/dev/null 2>"${nmap_err}" &
  nmap_pid=$!
else
  final_nmap_cmd=(nmap --privileged -p"$ports" -sC -sV -Pn -sS --min-rate 1000 "$target" -oN "${tmpdir}/nmap.out")
  "${final_nmap_cmd[@]}" 1>/dev/null 2>"${nmap_err}" &
  nmap_pid=$!
fi

# spinner for targeted scan with port counter
nf_spinner=( '⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' )
nf_colors=( $'\e[1;36m' $'\e[0;36m' )
j=0
delay_nmap=0.10
dots=0
maxdots=6
port_count=$(echo "$ports" | tr ',' '\n' | wc -l)

while kill -0 "$nmap_pid" 2>/dev/null; do
  color="${nf_colors[$(( j % ${#nf_colors[@]} ))]}"
  frame="${nf_spinner[$(( j % ${#nf_spinner[@]} ))]}"
  dots=$(( (dots + 1) % (maxdots + 1) ))
  dotstr="$(printf '.%.0s' $(seq 1 $dots))"
  tick_for_target=$(( j / breathe_target_slowdown ))
  bc="$(_breathe_phase "$tick_for_target")"
  printf '\r%bTargeted Nmap Scan [ %b%s on %b ports%s ]%b %b%s %s %b  ' \
    "${BOLD}" "${bc}" "${target}" "${port_count}" "${RESET}" "${RESET}" \
    "${color}" "${frame}" "${dotstr}" "${RESET}"
  (( j++ ))
  sleep "$delay_nmap"
done

wait "$nmap_pid"
nmap_rc=$?

# clear spinner line
printf '\r\033[K'

# print Nmap output
echo
printf '%bNMAP STDOUT:%b\n' "${FG_CYAN}" "${RESET}"
if [[ -n "${nmap_oA_prefix}" ]] && [[ -f "${nmap_oA_prefix}.nmap" ]]; then
  sed -n '1,$p' "${nmap_oA_prefix}.nmap" || true
elif [[ -n "${nmap_oN_path}" ]] && [[ -f "${nmap_oN_path}" ]]; then
  sed -n '1,$p' "${nmap_oN_path}" || true
elif [[ -f "${tmpdir}/nmap.out" ]]; then
  sed -n '1,$p' "${tmpdir}/nmap.out" || true
else
  printf '%bNo Nmap output found (check stderr: %s).%b\n' "${FG_RED_BOLD}" "${nmap_err}" "${RESET}"
fi

# show nmap stderr if present
if [[ -s "${nmap_err}" ]]; then
  printf '\n%bNmap stderr (trimmed)%b\n' "${FG_RED_BOLD}" "${RESET}"
  sed -n '1,200p' "${nmap_err}" || true
fi

# -----------------------------
# Summary
# -----------------------------
printf '\nScan Summary for %b%s%b\n' "${FG_MAGENTA}" "${target}" "${RESET}"
printf 'Discovered ports:%b %s%b\n' "${FG_MAGENTA}" "$ports" "${RESET}"
printf 'Total ports scanned:%b %d%b\n' "${FG_MAGENTA}" "$port_count" "${RESET}"

if (( use_rustscan )); then
  printf 'Discovery method:%b Rustscan%b' "${FG_MAGENTA}" "${RESET}"
else
  printf '%bDiscovery method:%b Nmap probe' "${FG_MAGENTA}" "${RESET}"
fi
printf '\n'

# final message
if [[ -n "${nmap_oA_prefix}" ]]; then
  printf '%bNmap Targeted Scan finished.%b Outputs saved to: %s.nmap, %s.gnmap, %s.xml\n' \
    "${BOLD}" "${RESET}" "${nmap_oA_prefix}" "${nmap_oA_prefix}" "${nmap_oA_prefix}"
elif [[ -n "${nmap_oN_path}" ]]; then
  printf '%bNmap Targeted Scan finished.%b Output saved to: %s\n' \
    "${BOLD}" "${RESET}" "${nmap_oN_path}"
else
  printf '%bNmap Targeted Scan finished.%b\n' "${BOLD}" "${RESET}"
fi
exit "${nmap_rc:-0}"